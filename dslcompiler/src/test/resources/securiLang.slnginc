// This is an OLD OLD version (before switching to core versions)

category System {

   abstractAsset Machine {

      | physicalAccess
            info: "Attackers have physical access to the machine if they have compromised its physical zone or gained physical access to the underlying platform."
            ->    executees.physicalAccess,
            denialOfService

      | networkAccess
            info: "Attackers have network access to the machine if they have compromised its network zone or gained network access to the underlying platform."
            ->    executees.networkAccess

      | executesNetworkService
            rationale: "This needs to be here in ordert to be overridden in Software. If the model does not contain any explicit relationship from the NetworkService to a Network, it is assumed that the underlying hardware's network is possible to reach for an attacker with root on Service."

      | legitimateConnect
            -> _machineCoreLegitimateConnect

      | attemptMaliciousConnect
            -> maliciousConnect,
               legitimateConnect

      | maliciousConnect
            -> _machineCoreMaliciousConnect

      | _machineCoreMaliciousConnect
            -> product.searchForUnprivilegedVulnerability,
               rootAccount.attemptCrack,
               userAccounts.attemptCrack,
               deployConfidentialityExploit,
               deployIntegrityExploit,
               deployAvailabilityExploit,
               legitimateConnect

      | _machineCoreLegitimateConnect
            ->    userLogin,
               rootLogin,
               uncontrolledAccess

      | userAccess
            info: "User access equates the access of a *NIX, non-admin user. Thus, the OS is accessible, e.g. through a shell, but user does not belong to sudoers."
            ->    _machineCoreUserAccess

      | _machineCoreUserAccess
            ->    product.searchForPrivilegeEscalationVulnerability,
               attemptMaliciousConnect,
               data.requestAccess

      | rootAccess
            info: "Root access leads to full control of all data stored on the machine. Furthermore, all software using this as an execution platform is compromised."
            ->    _machineCoreRootAccess

      | _machineCoreRootAccess
            ->    denialOfService,
               rootAccount.attemptCrack,
               userAccounts.attemptCrack,
               userAccess,
               data.readAccess,
               data.writeAccess,
               data.delete,
               executees.rootAccess

      | userAuthenticate
            info: "Does the attacker have the credentials of a user account?"
            ->    userLogin

      | rootAuthenticate
            info: "Does the attacker have the credentials of a root account?"
            ->    rootLogin

      & userLogin
            ->    userAccess

      & rootLogin
            ->    rootAccess

      3 rootAccountExists
            info: "If no account is connected as root, this defense step is compromised."
            <-    rootAccount
            ->  uncontrolledAccess

      3 userAccountExists
            info: "If no account is connected as user, this defense step is compromised."
            <-    userAccounts
            ->  uncontrolledAccess

      & uncontrolledAccess
            info: "If no accounts are connected to this machine, then connect leads directly to userAccess. To model direct root access, explicitly add root account."
            rationale: "It is implicitly assumed that there is an unknown root account with uncrackable credentials, so a priv.esc. exploit is required for root access. Furthermore, stored data is assumed unavailable, because that requires either an explicit user account or root access. But root access also allows connect to executor (i.e. shell), which seems excessive."
            // For better resolution, we could introduce an additional compromise beyond root, that granted executor.connect, while root did not, thus representing the subversion of the acutal code (something an admin of a software is not necessarily capable of). Functionally equivalent would be to add a user type "Admin", with access to data but not executor.
            ->    rootAccess

      & deployConfidentialityExploit [ExponentialDistribution(10.0)]
            rationale: "If there is no software product (there really should be), this step is reached directly from connect. Thus, it is assumed that the attacker has already developed an exploit."
            ->    confidentialityExploit

      & deployIntegrityExploit [ExponentialDistribution(10.0)]
            rationale: "If there is no software product (there really should be), this step is reached directly from connect. Thus, it is assumed that the attacker has already developed an exploit."
            ->    integrityExploit

      & deployAvailabilityExploit [ExponentialDistribution(10.0)]
            rationale: "If there is no software product (there really should be), this step is reached directly from connect. Thus, it is assumed that the attacker has already developed an exploit."
            ->    availabilityExploit

      | confidentialityExploit
            -> executees.confidentialityExploit,
               data.readAccess

      | integrityExploit
            // For better resolution, we should differentiate between root and user access
            -> executees.integrityExploit,
               rootAccess

      | availabilityExploit
            -> executees.availabilityExploit,
               denialOfService

      & deployXSSExploit
         rationale: "This is a placeholder for an attack step used in WebApplicationService."

      | denialOfService
            -> executees.denialOfService,
               data.denyAccess

      # isPatched
         info: "The probability that the system is fully patched on any randomly selected day."
            -> product.findUnprivilegedPublicConfidentialityVulnerability,
               product.findUnprivilegedPublicIntegrityVulnerability,
               product.findUnprivilegedPublicAvailabilityVulnerability,
               product.findUnprivilegedPublicXSSVulnerability,
               product.findPrivilegeEscalationPublicConfidentialityVulnerability,
               product.findPrivilegeEscalationPublicIntegrityVulnerability,
               product.findPrivilegeEscalationPublicAvailabilityVulnerability,
               product.findPrivilegeEscalationPublicXSSVulnerability

      # noLogin
         info: "Some services, such as SSH, can be logged onto, while others, such as NTPD, cannot."
            -> userLogin,
               rootLogin
   }

   asset PhysicalMachine extends Machine {
      | executesNetworkService
            -> networks.accessLayer2
   }

   abstractAsset Software extends Machine {
      | userAccess
            ->    _softwareCoreUserAccess

      | _softwareCoreUserAccess
            info: "User access equates the access of a *NIX, non-admin user. Thus, shell services are available, but user does not belong to sudoers."
            ->    _machineCoreUserAccess,
               shellToExecutor


      | rootAccess
            ->    _softwareCoreRootAccess

      | _softwareCoreRootAccess
            info: "Root access leads to control of all accounts that the software owns, as well as to a connection to the executing platform. In that regard, an attacker with root access has the same access as an attacker that controls the program code of the compromised software."
            // Perhaps Root should be complemented by something like "Pwned", where Pwned could represent the ability to change to software program (in particular leading to executor.maliciousConnect). This ability is not generally given root administrators (only in applications that are shell). In other words, currently, rootLogin will always lead to shell.
            ->    _machineCoreRootAccess,
               assignedAccounts.authenticate,
               executor.attemptMaliciousConnect

      # notShell
            info: "Some softwares provide direct access to the underlying executor. For instance, the Bash application provides access to the underlying OS."
            -> shellToExecutor

      & shellToExecutor
            -> executor.attemptMaliciousConnect

      | executesNetworkService
            // This could perhaps be replaced with a multiasset-hop directly to the connected networks.
            info: "This software directly or indirectly executes a network service. Attackers that reach this point will eventually also reach layer 2 of the connected networks."
            rationale: "If the model does not contain any explicit relationship from the NetworkService to a Network, it is assumed that the underlying hardware's network is possible to reach for an attacker with root on Service."
            -> executor.executesNetworkService
   }

   asset OperatingSystem extends Software {
      | attemptMaliciousConnect
         // TODO: Harmonize the structure and naming of endpoint protection with IDPS and firewall. Perhaps even create an attack graph pattern?
         // TODO: Endpoint protection should extend to the network services running on the OS, I think? Or maybe not?
            -> attemptMaliciousConnectNoEndpointProtection,
               attemptMaliciousConnectBypassEndpointProtection,
               legitimateConnect


      & attemptMaliciousConnectNoEndpointProtection
            info: "Endpoint protection comes from (i) the existence of a (ii) correctly configured endpoint protection system."
            -> maliciousConnect

      | attemptMaliciousConnectBypassEndpointProtection [ExponentialDistribution(2.2)]
         rationale: "This number is an exponential adaption of 'J. A. Morales, R. Sandhu, S. Xu, Evaluating detection and treatment effec- tiveness of commercial anti-malware programs, in: Malicious and Unwanted Software (MALWARE), 2010 5th International Conference on, IEEE, 2010, pp. 31â€“38.'"
         // This number should be specialized for specific products for two reasons: (i) antimalware sucks more now than in 201, and (ii) securiLang includes all kinds of endpoint protection, not only antimalware.
            -> maliciousConnect

      # endPointProtection
            -> attemptMaliciousConnectNoEndpointProtection
   }

   asset VirtualMachine extends Software {
   }

   asset Container extends Application {
   }

   asset HypervisorTypeI extends Software {
   }

   asset HypervisorTypeII extends Application {
   }

   abstractAsset Application extends Software {
   }

   asset Service extends Application {
      | userAccess
            ->    _softwareCoreUserAccess
   }

   asset PeripheralService extends Service {
      | physicalAccess
            ->    attemptMaliciousConnect
   }

   asset NetworkService extends Service {
      | rootAccess
            rationale: "If the model does not contain any explicit relationship from the NetworkService to a Network, it is assumed that the underlying hardware's network is possible to reach for an attacker with root on Service."
            ->    _networkServiceCoreRootAccess

      | _networkServiceCoreRootAccess
            rationale: "If the model does not contain any explicit relationship from the NetworkService to a Network, it is assumed that the underlying hardware's network is possible to reach for an attacker with root on Service."
            ->    _softwareCoreRootAccess,
               exposureNetworks.accessLayer2,
               executesThroughDefaultNetworkInterface,
               dataflows.respondAccess

      & executesThroughDefaultNetworkInterface
            rationale: "If the model does not contain any explicit relationship from the NetworkService to a Network, it is assumed that the underlying hardware's network is possible to reach for an attacker with root on Service."
            -> executesNetworkService

      | networkAccess
            ->    attemptMaliciousConnect

      3 noExposureNetwork
            rationale: "If the model does not contain any explicit relationship from the NetworkService to a Network, it is assumed that the underlying hardware's network is possible to reach for an attacker with root on Service."
            <- exposureNetworks
            -> executesThroughDefaultNetworkInterface
            // Here, we would benefit from multi-hop naviation to find the network connected to the physical machine
   }

   asset WebServer extends NetworkService {
   }

   asset AuthenticationService extends Service
      rationale: "Authentication service is not actively involved in account authentication (e.g. key.read leads directly to account.authenticate), because that is not needed for the attacks we are interested in."
      {
      | rootAccess
            info: "If a service is tasked with authentication of accounts, its compromise leads to the compromise of the associated accounts."
            ->    _softwareCoreRootAccess,
               authenticatedAccounts.authenticate

      | attemptToBreakImplementation
            ->    authenticatedAccounts.exploitBrokenImplementation

       # unbrokenImplementation
         info: "Even with a solid cryptographic scheme, errors may be present in the implementaion, thus making the encryption vulnerable to attack."
            ->    authenticatedAccounts.exploitBrokenImplementation

      # backOff
            info: "The number of logon attempts is limited."
            -> authenticatedAccounts.backOffDisabled
   }

   asset EncryptionService extends Service {
      | rootAccess
            info: "If a service is tasked with authentication of accounts, its compromise leads to the compromise of the associated accounts."
            ->    _softwareCoreRootAccess,
               encryptedData.read,
               encryptedData.write

       # unbrokenCryptography
         // unbrokenCrypto and unbrokenImplementation should have public, zero-day, etc. attack steps and thereby follow the logic of other exploits. Currently, compromise happens instantaneously.
         info: "Because we define Key.sufficientEntropy at 70 bits, corresponding to 12 alphanumeric symbols, even MD5 will withstand a brute-force (non-dictionary-based) cracking attempt. Thus, only really crappy encryption schemes should be marked as broken."
            ->    encryptedData.exploitBrokenCryptography

       # unbrokenImplementation
         info: "Even with a solid cryptographic scheme, errors may be present in the implementaion, thus making the encryption vulnerable to attack."
            ->    encryptedData.exploitBrokenImplementation
   }

   asset Client extends Application {
      | userAccess
            ->    _softwareCoreUserAccess,
               dataflows.requestAccess
   }

   asset Browser extends Client {
   }

   asset WebApplicationClient extends Client {
   }

   asset WebApplicationService extends NetworkService {

      | rootAccess
            rationale: "If the model does not contain any explicit relationship from the NetworkService to a Network, it is assumed that the underlying hardware's network is possible to reach for an attacker with root on Service."
            ->    _networkServiceCoreRootAccess,
               programDistributionFlow.respondAccess

         & deployXSSExploit
         rationale: "."
            -> programDistributionFlow.respondAccess
   }

   asset Product {
      // Eventually, we should harmonize these with CVSS 3.0. However, that will result in 150 different attack steps, each requiring its unique TTC for each product, so we postpone to the future, as the current implementation is at least semi-compliant.
      | searchForUnprivilegedVulnerability
            ->    findUnprivilegedZeroDayConfidentialityVulnerability,
               findUnprivilegedZeroDayIntegrityVulnerability,
               findUnprivilegedZeroDayAvailabilityVulnerability,
               findUnprivilegedPublicConfidentialityVulnerability,
               findUnprivilegedPublicIntegrityVulnerability,
               findUnprivilegedPublicAvailabilityVulnerability,
               findUnprivilegedPublicConfidentialityExploit,
               findUnprivilegedPublicIntegrityExploit,
               findUnprivilegedPublicAvailabilityExploit

      | searchForPrivilegeEscalationVulnerability
            -> findPrivilegeEscalationZeroDayConfidentialityVulnerability,
               findPrivilegeEscalationZeroDayIntegrityVulnerability,
               findPrivilegeEscalationZeroDayAvailabilityVulnerability,
               findPrivilegeEscalationPublicConfidentialityVulnerability,
               findPrivilegeEscalationPublicIntegrityVulnerability,
               findPrivilegeEscalationPublicAvailabilityVulnerability,
               findPrivilegeEscalationPublicConfidentialityExploit,
               findPrivilegeEscalationPublicIntegrityExploit,
               findPrivilegeEscalationPublicAvailabilityExploit

      | findUnprivilegedZeroDayConfidentialityVulnerability [ExponentialDistribution(100.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developConfidentialityExploit

      | findUnprivilegedZeroDayIntegrityVulnerability [ExponentialDistribution(200.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developIntegrityExploit

      | findUnprivilegedZeroDayAvailabilityVulnerability [ExponentialDistribution(50.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developAvailabilityExploit

      | findPrivilegeEscalationZeroDayConfidentialityVulnerability [ExponentialDistribution(50.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developConfidentialityExploit

      | findPrivilegeEscalationZeroDayIntegrityVulnerability [ExponentialDistribution(100.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developIntegrityExploit

      | findPrivilegeEscalationZeroDayAvailabilityVulnerability [ExponentialDistribution(25.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developAvailabilityExploit

      & findUnprivilegedPublicConfidentialityVulnerability [ExponentialDistribution(50.0)]
         info: "If the machine is unpatched, how long before a confidentiality vulnerability is publically disclosed?"
         rationale: "These numbers should be specified uniquely for each product, based on the NVD."
            ->    developConfidentialityExploit

      & findUnprivilegedPublicIntegrityVulnerability [ExponentialDistribution(100.0)]
         info: "If the machine is unpatched, how long before an integrity vulnerability is publically disclosed?"
         rationale: "These numbers should be specified uniquely for each product, based on the NVD."
            ->    developIntegrityExploit

      & findUnprivilegedPublicAvailabilityVulnerability [ExponentialDistribution(25.0)]
         info: "If the machine is unpatched, how long before an availability vulnerability is publically disclosed?"
         rationale: "These numbers should be specified uniquely for each product, based on the NVD."
            ->    developAvailabilityExploit

      & findPrivilegeEscalationPublicConfidentialityVulnerability [ExponentialDistribution(25.0)]
         info: "If the machine is unpatched, how long before a confidentiality vulnerability is publically disclosed?"
         rationale: "These numbers should be specified uniquely for each product, based on the NVD."
            ->    developConfidentialityExploit

      & findPrivilegeEscalationPublicIntegrityVulnerability [ExponentialDistribution(50.0)]
         info: "If the machine is unpatched, how long before an integrity vulnerability is publically disclosed?"
         rationale: "These numbers should be specified uniquely for each product, based on the NVD."
            ->    developIntegrityExploit

      & findPrivilegeEscalationPublicAvailabilityVulnerability [ExponentialDistribution(12.0)]
         info: "If the machine is unpatched, how long before an availability vulnerability is publically disclosed?"
         rationale: "These numbers should be specified uniquely for each product, based on the NVD."
            ->    developAvailabilityExploit

      | developConfidentialityExploit [GammaDistribution(0.699, 38.2)]
         info: "According to 'Ablon, Lillian, and Andy Bogart. Zero Days, Thousands of Nights: The Life and Times of Zero-Day Vulnerabilities and Their Exploits. Rand Corporation, 2017', it takes GammaDistribution[0.699, 38.2] days to develop a zero day exploit after it as been discovered."
            ->    obtainConfidentialityExploit

      | developIntegrityExploit [GammaDistribution(0.699, 38.2)]
         info: "According to 'Ablon, Lillian, and Andy Bogart. Zero Days, Thousands of Nights: The Life and Times of Zero-Day Vulnerabilities and Their Exploits. Rand Corporation, 2017', it takes GammaDistribution[0.699, 38.2] days to develop a zero day exploit after it as been discovered."
            ->    obtainIntegrityExploit

      | developAvailabilityExploit [GammaDistribution(0.699, 38.2)]
         info: "According to 'Ablon, Lillian, and Andy Bogart. Zero Days, Thousands of Nights: The Life and Times of Zero-Day Vulnerabilities and Their Exploits. Rand Corporation, 2017', it takes GammaDistribution[0.699, 38.2] days to develop a zero day exploit after it as been discovered."
            ->    obtainAvailabilityExploit

      & findUnprivilegedPublicConfidentialityExploit
         info: "It is revealed, e.g. by a vulnerability scan, that the machine is vulnerable to a publicly available exploit. (Naturally, this also means that there is a vulnerability, regardless of the state of findPrivilegeEscalationPublicVulnerability.)"
            -> obtainConfidentialityExploit

      & findUnprivilegedPublicIntegrityExploit
         info: "It is revealed, e.g. by a vulnerability scan, that the machine is vulnerable to a publicly available exploit. (Naturally, this also means that there is a vulnerability, regardless of the state of findPrivilegeEscalationPublicVulnerability.)"
            -> obtainIntegrityExploit

      & findUnprivilegedPublicAvailabilityExploit
         info: "It is revealed, e.g. by a vulnerability scan, that the machine is vulnerable to a publicly available exploit. (Naturally, this also means that there is a vulnerability, regardless of the state of findPrivilegeEscalationPublicVulnerability.)"
            -> obtainAvailabilityExploit

      & findPrivilegeEscalationPublicConfidentialityExploit
         info: "It is revealed, e.g. by a vulnerability scan, that the machine is vulnerable to a publicly available exploit. (Naturally, this also means that there is a vulnerability, regardless of the state of findPrivilegeEscalationPublicVulnerability.)"
            -> obtainConfidentialityExploit

      & findPrivilegeEscalationPublicIntegrityExploit
         info: "It is revealed, e.g. by a vulnerability scan, that the machine is vulnerable to a publicly available exploit. (Naturally, this also means that there is a vulnerability, regardless of the state of findPrivilegeEscalationPublicVulnerability.)"
            -> obtainIntegrityExploit

      & findPrivilegeEscalationPublicAvailabilityExploit
         info: "It is revealed, e.g. by a vulnerability scan, that the machine is vulnerable to a publicly available exploit. (Naturally, this also means that there is a vulnerability, regardless of the state of findPrivilegeEscalationPublicVulnerability.)"
            -> obtainAvailabilityExploit

      | obtainConfidentialityExploit
            ->    machines.deployConfidentialityExploit

      | obtainIntegrityExploit
            ->    machines.deployIntegrityExploit

      | obtainAvailabilityExploit
            ->    machines.deployAvailabilityExploit

      | findUnprivilegedZeroDayXSSVulnerability
         rationale: "Placeholder"

      | findUnprivilegedPublicXSSVulnerability
         rationale: "Placeholder"

      | findUnprivilegedPublicXSSExploit
         rationale: "Placeholder"

      | findPrivilegeEscalationZeroDayXSSVulnerability
         rationale: "Placeholder"

      | findPrivilegeEscalationPublicXSSVulnerability
         rationale: "Placeholder"

      | findPrivilegeEscalationPublicXSSExploit
         rationale: "Placeholder"

      | developXSSExploit
         info: "Placeholder."

      | obtainXSSExploit
         info: "Placeholder."

      # unprivilegedConfidentialityExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findUnprivilegedPublicConfidentialityExploit

      # unprivilegedIntegrityExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findUnprivilegedPublicIntegrityExploit

      # unprivilegedAvailabilityExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findUnprivilegedPublicAvailabilityExploit

      # unprivilegedXSSExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findUnprivilegedPublicXSSExploit

      # privilegeEscalationConfidentialityExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findPrivilegeEscalationPublicConfidentialityExploit

      # privilegeEscalationIntegrityExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findPrivilegeEscalationPublicIntegrityExploit

      # privilegeEscalationAvailabilityExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findPrivilegeEscalationPublicAvailabilityExploit

      # privilegeEscalationXSSExploitNotPublicallyAvailable
         info: "This should be false if, e.g., a vulnerability scan finds a publicly exploitable vulnerability. Otherwise true."
            -> findPrivilegeEscalationPublicXSSExploit
   }

   asset WebApplicationServiceProduct extends Product {
      | searchForUnprivilegedVulnerability
            ->    findUnprivilegedZeroDayConfidentialityVulnerability,
               findUnprivilegedZeroDayIntegrityVulnerability,
               findUnprivilegedZeroDayAvailabilityVulnerability,
               findUnprivilegedZeroDayXSSVulnerability,
               findUnprivilegedPublicConfidentialityVulnerability,
               findUnprivilegedPublicIntegrityVulnerability,
               findUnprivilegedPublicAvailabilityVulnerability,
               findUnprivilegedPublicXSSVulnerability,
               findUnprivilegedPublicConfidentialityExploit,
               findUnprivilegedPublicIntegrityExploit,
               findUnprivilegedPublicAvailabilityExploit,
               findUnprivilegedPublicXSSExploit

      | searchForPrivilegeEscalationVulnerability
            -> findPrivilegeEscalationZeroDayConfidentialityVulnerability,
               findPrivilegeEscalationZeroDayIntegrityVulnerability,
               findPrivilegeEscalationZeroDayAvailabilityVulnerability,
               findPrivilegeEscalationZeroDayXSSVulnerability,
               findPrivilegeEscalationPublicConfidentialityVulnerability,
               findPrivilegeEscalationPublicIntegrityVulnerability,
               findPrivilegeEscalationPublicAvailabilityVulnerability,
               findPrivilegeEscalationPublicXSSVulnerability,
               findPrivilegeEscalationPublicConfidentialityExploit,
               findPrivilegeEscalationPublicIntegrityExploit,
               findPrivilegeEscalationPublicAvailabilityExploit,
               findPrivilegeEscalationPublicXSSExploit

      | findUnprivilegedZeroDayXSSVulnerability [ExponentialDistribution(10.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developXSSExploit

      | findUnprivilegedPublicXSSVulnerability [ExponentialDistribution(5.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developXSSExploit

      | findUnprivilegedPublicXSSExploit
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developXSSExploit

      | findPrivilegeEscalationZeroDayXSSVulnerability [ExponentialDistribution(5.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developXSSExploit

      | findPrivilegeEscalationPublicXSSVulnerability  [ExponentialDistribution(3.0)]
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developXSSExploit

      | findPrivilegeEscalationPublicXSSExploit
         rationale: "These numbers should be specified uniquely for each product, based on the Time Between Vulnerability Disclosure (TBVD) paper by Johnson et al.."
            ->    developXSSExploit

      | developXSSExploit [GammaDistribution(0.699, 38.2)]
         info: "According to 'Ablon, Lillian, and Andy Bogart. Zero Days, Thousands of Nights: The Life and Times of Zero-Day Vulnerabilities and Their Exploits. Rand Corporation, 2017', it takes GammaDistribution[0.699, 38.2] days to develop a zero day exploit after it as been discovered."
            ->    obtainXSSExploit

      | obtainXSSExploit
            ->    machines.deployXSSExploit
   }
}

category Networking {
   asset Network
      // For WPA, if the attacker is in range of wifi, a Pairwise Transient Key (PTK) can be captured if eavesdropping on a legitimate handshake between AP and station. From the PTK, the Pre-Shared Key (PSK), can be brute force guessed if it is simple. (PTK from PSK includes PBKDF2 with 4096 iterations, so guessing will be slow.)
      // This should be modelled as folows: An unencrypted dataflow represents the handshake. The dataflow contains the PSK in the form of a Key (wrapped in encrypted Data). The PSK is then used as the encryption key of all dataflows over the WPA network.
      // The attacker will therefore be able to obtain the encrypted PSK. If cracked (a separate attack required), all (other) dataflows over the WPA network can be eavesdropped on.
      // To facilitate for the end user, the pre-processor/component should automatically add the PSK, relations between the handshake dataflow and new clients, and relations between the PSK and the dataflows that flow over the network.

      {
      | physicalAccess
            ->    accessLayer3,
               manInTheMiddle


      | accessLayer3
            info: "Layer 3 access implies the possibility to submit IP packets over the network. It does not imply the possibility to listen to others' trafic on the network. You are outside the router but with a possibility to communicate in to the network."
               // IDPS should affect the possibility of maliciousConnect
            ->    trafficRouters.forwarding,
               denialOfService

      | eavesdrop
            info: "Attackers can sometimes eavesdrop on the IP layer. Higher-layer encryption, such as HTTPS, may still prevent the compromise of information in dataflows."
            ->    dataflows.eavesdrop

      | denialOfService
      // The dataflows that pass through a network are given by a dynamic calculation. (These should, in the future, be computed in a preprocessing step that completes user models.)
            info: "The network is made unavailable."
            ->    dataflows.denialOfService

      | manInTheMiddle
               info: "Attackers can sometimes intercept and tamper with communications on the IP layer. Higher-layer encryption and authentication, such as HTTPS, may still prevent the compromise of information in dataflows."
            ->    accessLayer3,
               eavesdrop,
               dataflows.manInTheMiddle,
               trafficRouters.denialOfService
      }

   asset WAN extends Network {}

   asset Ethernet extends Network
      // For WPA, if the attacker is in range of wifi, a Pairwise Transient Key (PTK) can be captured if eavesdropping on a legitimate handshake between AP and station. From the PTK, the Pre-Shared Key (PSK), can be brute force guessed if it is simple. (PTK from PSK includes PBKDF2 with 4096 iterations, so guessing will be slow.)
      // This should be modelled as folows: An unencrypted dataflow represents the handshake. The dataflow contains the PSK in the form of a Key (wrapped in encrypted Data). The PSK is then used as the encryption key of all dataflows over the WPA network.
      // The attacker will therefore be able to obtain the encrypted PSK. If cracked (a separate attack required), all (other) dataflows over the WPA network can be eavesdropped on.
      // To facilitate for the end user, the pre-processor/component should automatically add the PSK, relations between the handshake dataflow and new clients, and relations between the PSK and the dataflows that flow over the network.

      {
      | physicalAccess
            ->    bypassPortSecurity

      & bypassPortSecurity
            ->    bypassAccessControl

      | bypassAccessControl
            ->    accessLayer2

      | accessLayer2
            info: "Hosts with a MAC address on the network have Layer 2 access."
            rationale: "Access to layer 2 may enable eavesdropping, depending on the kind of network, as well as ARP cache poisoning either on the router side or any of the hosts on the network. (Router side ARP cache poisoning is modelled as a property on the network.)"
            ->    accessLayer3,
               aRPCachePoisoning

      | accessLayer3
            info: "Layer 3 access implies the possibility to submit IP packets over the network. It does not imply the possibility to listen to others' trafic on the network. You are outside the router but with a possibility to communicate in to the network."
               // IDPS should affect the possibility of maliciousConnect
            ->    exposedServices.attemptMaliciousConnect,
               trafficRouters.forwarding,
               denialOfService,
               physicalMachines.networkAccess,
               virtualMachines.networkAccess

      & aRPCachePoisoning
         info: "ARP spoofing works on all common networks, both wirebound and wireless. For WPA2Enterprise, it can be exploited due to Hole196 (cf. https://www.cwnp.com/forums/posts?postNum=300580)."
            ->    manInTheMiddle

      # portSecurity
            info: "You can use port security to restrict a port's ingress traffic by limiting the MAC addresses that are allowed to send traffic into the port."
            rationale: "http://www.cisco.com/c/en/us/td/docs/switches/lan/catalyst6500/ios/12-2SX/configuration/guide/book/port_sec.html"
            ->    bypassPortSecurity

      # staticARPTables
            ->    aRPCachePoisoning

      | manInTheMiddle
               info: "Attackers can sometimes intercept and tamper with communications on the IP layer. Higher-layer encryption and authentication, such as HTTPS, may still prevent the compromise of information in dataflows."
            ->    accessLayer2,
               eavesdrop,
               dataflows.manInTheMiddle,
               trafficRouters.denialOfService
      }

   asset Wifi extends Ethernet
      // For WPA, if the attacker is in range of wifi, a Pairwise Transient Key (PTK) can be captured if eavesdropping on a legitimate handshake between AP and station. From the PTK, the Pre-Shared Key (PSK), can be brute force guessed if it is simple. (PTK from PSK includes PBKDF2 with 4096 iterations, so guessing will be slow.)
      // This should be modelled as folows: An unencrypted dataflow represents the handshake. The dataflow contains the PSK in the form of a Key (wrapped in encrypted Data). The PSK is then used as the encryption key of all dataflows over the WPA network.
      // The attacker will therefore be able to obtain the encrypted PSK. If cracked (a separate attack required), all (other) dataflows over the WPA network can be eavesdropped on.
      // To facilitate for the end user, the pre-processor/component should automatically add the PSK, relations between the handshake dataflow and new clients, and relations between the PSK and the dataflows that flow over the network.

      {
      | physicalAccess
            ->    bypassPortSecurity,
               sniffUnencryptedHandshake,
               wifiTrafficRouters.evilTwinHandshakeSniff

      & bypassPortSecurity
            ->    uncontrolledAccess,
               userLogin

      | userAuthenticate
            -> userLogin

      & userLogin
            -> bypassAccessControl

      & uncontrolledAccess
            ->    bypassAccessControl,
               eavesdropOpenNetwork

      # encryptedHandshake
            -> sniffUnencryptedHandshake

      & sniffUnencryptedHandshake
            -> sniffHandshake

      & sniffEncryptedHandshake
            -> sniffHandshake

      | sniffHandshake
         info: "If unencrypted, the initial handshake, containing authentication challenges and responses, can be sniffed."
            -> hashedCredentials.readAccess

      | bypassAccessControl
            ->    accessLayer2,
               wifiTrafficRouters.evilTwinMitM

      # notOpen
            info: "Some networks, such as open wifi networks, can be sniffed on the MAC layer, because the traffic is broadcasted and open."
            ->    uncontrolledAccess,
               eavesdropOpenNetwork

      | accessLayer3
            info: "Layer 3 access implies the possibility to submit IP packets over the network. It does not imply the possibility to listen to others' trafic on the network. You are outside the router but with a possibility to communicate in to the network."
               // IDPS should affect the possibility of maliciousConnect
            ->    exposedServices.attemptMaliciousConnect,
               wifiTrafficRouters.forwarding,
               denialOfService,
               physicalMachines.networkAccess,
               virtualMachines.networkAccess


      & eavesdropOpenNetwork
            ->    eavesdrop

      | manInTheMiddle
               info: "Attackers can sometimes intercept and tamper with communications on the IP layer. Higher-layer encryption and authentication, such as HTTPS, may still prevent the compromise of information in dataflows."
            ->    accessLayer2,
               eavesdrop,
               dataflows.manInTheMiddle,
               wifiTrafficRouters.denialOfService
      }

   asset Router extends Service {

      | rootAccess
            ->    _softwareCoreRootAccess,
               trafficNetworks.manInTheMiddle,
               forwarding

      3 firewallExists
            <- firewall
            -> noFirewallProtection

      | noFirewallProtection
            info: "Firewall protection comes from (i) the existence of a (ii) correctly configured firewall."
            -> bypassFirewall

      | forwarding
            rationale: "Forwarding is the lightest interaction with the router, where the router simply retransmits received messages. Vulnerabilities may, however, lead to compromise of the router as well as of the associated firewall. Therefore, Forwarding leads to Connect."
            ->    bypassFirewall,
               attemptMaliciousConnect,
               // Does IPDS affect the TTC of maliciousConnect here?
               firewall.attemptMaliciousConnect

      & bypassFirewall
            -> trafficNetworks.accessLayer3

      | denialOfService
            ->    trafficNetworks.denialOfService
   }

   asset WifiRouter extends Router {

      3 serverCertificate
            info: "WPA2-Enterprise can protect the initial handshake between clients and access points by a TLS tunnel, which requires a server certificate."
            <- certificate
            -> bypassHandshakeEncryption

      | bypassHandshakeEncryption
            rationale: "WPA2-Enterprise can use PEAP, which protects the initial handshake in a TLS tunnel (some alterntives, such as EAP-MSCHAPv2, are unprotected). For TLS tunnels, the server needs a certificate. If the attacker has the certificate, or clients fail to verify, the handshake and its hashed keys can be captured for subsequent cracking attempts. A pre-shared key is used to authenticate in the initial handshake. In WPA2PSK, the handshake is unencrypted and its hashed keys can be captured for subsequent cracking attempts. PBKDF2 is used, so only dictionary attacks and low-entropy passwords are feasible to crack."
            // This step should not lead directly to the evilTwin below, because access to the certificate only allows the initial handshake, in which the user credentials are checked. Then, the individual credentials of each target user need to be cracked. This is as hard as in the PSK case; PBKDF2 4096 is used.
            -> wifiTrafficNetworks.sniffEncryptedHandshake,
               evilTwinMitM

       & evilTwinHandshakeSniff
            rationale: "Access to the router cert (WPA2Enterprise), the pre-shared key (WPA2PSK, WPA), or that the is network open, is required for the evil twin attack. WPA2-Enterprise supports a number of EAPs - Extensible Authentication Protocols. The security depends on which EAP you use, and how you configure it. Some EAPs more vulnerable to an 'evil twin' attack than PSK, as an attacker doesn't need to brute force the key. Fortunately, a number of EAPs are secure against an evil twin. One approach is to use TLS internally; PEAP is a popular option that does this. To be secure against an evil twin, you must enable certificate verification and distribute the certificate to all your clients. (https://security.stackexchange.com/questions/46849/does-wpa2-enterprise-mitigate-evil-twin-attacks)"
            ->    wifiTrafficNetworks.sniffEncryptedHandshake

      & evilTwinMitM
         rationale: "A rogue hotspot can, under some circumstances, impersonate the AP and forward traffic (e.g. to the authentic AP). For open networks, a stronger signal than the authentic AP is sufficient. For WPA2-PSK, the attacker needs the PSK to complete the four-way handshake. For WPA2-Enterprise with PEAP, the attacker needs the server certificate (or that the client sloppily ignores server certificate authentication) to spoof the Radius server (to access the TLS tunnel that protects the four-way handshake) as well as the user's credentials, to complete the four-way handshake, authenticating both client and server to each other. (https://www.slideshare.net/sensepost/improvement-in-rogue-access-points-sensepost-defcon-22)"
            -> wifiTrafficNetworks.manInTheMiddle
   }
}

category Communication {

   asset Information
      info: "Information can be stored as data and transmitted in data flows. Data and data flows are syntactic forms of the semantics represented by the Information asset. Thus, multiple data and data flow assets can contain the same information."
      {
      | read
         info: "When information is read by the attacker, any associated confidentiality costs are incurred. It is sufficient that the attacker reads a single data or data flow to breach confidentiality."

      & write
         info: "When information is written by the attacker, any associated integrity costs are incurred. The attacker must, however, compromise all data and data flows in order to breach integrity. Thus, if the records of an ATM are modified, this might incur no cost as long as the master data is untouched."

      & delete
         info: "When information is deleted by the attacker, any associated availability costs are incurred. The attacker must, however, delete all data and data flows in order to breach integrity. Thus, if malware wipes a hard drive, this might incur no cost as long as a backup is easily accessible."
   }

   asset Data
   info: "Data is a concrete, syntactic representation of Information at rest."
   {
      | requestAccess
            info: "When stored on a machine, access control needs to be granted."
            -> userRead,
               userWrite,
               userDelete

      | anyUserAccountRead
            info: "A single account with read privileges (in conjuction with data access) is enough to read the data."
            -> userRead

      | anyUserAccountWrite
            info: "A single account with write privileges (in conjuction with data access) is enough to write the data."
            -> userWrite

      | anyUserAccountDelete
            info: "A single account with delete privileges (in conjuction with data access) is enough to delete the data."
            -> userDelete

      & userRead
            info: "An account with read privileges in conjuction with data access allows reading of the data."
            ->    readAccess

      & userWrite
            info: "An account with write privileges in conjuction with data access allows writing of the data."
            ->    writeAccess

      & userDelete
            info: "An account with delete privileges in conjuction with data access allows deletion of the data."
            ->    delete

      | readAccess
            info: "An attacker that reads the data, learns the encoded information unless it is encrypted."
            ->    read

      | writeAccess
            info: "Tampering with data leads to altering of the contained information only if there is no untouched copy elsewhere. If data is transmitted through data flows, those data flows will also be affected by the tampering."
            ->    write

      | deleteAccess
            info: "Tampering with data leads to altering of the contained information only if there is no untouched copy elsewhere. If data is transmitted through data flows, those data flows will also be affected by the tampering."
            -> delete

      | read
            info: "An attacker that reads the data, learns the encoded information."
            -> information.read,
               containedData.readAccess


      | write
            info: "Tampering with data leads to altering of the contained information only if there is no untouched copy elsewhere. If data is transmitted through data flows, those data flows will also be affected by the tampering."
            ->    delete,
               information.write,
               containedData.writeAccess,
               targetData.write,
               targetData.delete,
               dataflow.tamper

      | delete
            info: "Deletion of data leads to information loss only if there is no untouched copy elsewhere. If data is transmitted through data flows, those data flows will also be affected by the tampering."
            -> information.delete,
               containedData.deleteAccess

      | denyAccess
         info: "Denial-of-service attacks can make data unavailable."

       # sufficientEntropy
         info: "Keys need to feature suffciently high entropy to be uncrackable. 12 alphanumeric-character passwords, representing an entropy of about 70 bits contain sufficient entropy even for MD5. For online cracking, speeds are very much slower, around 1 Hash/s. Therefore, 70 bits is clearly excessive, even without back-off, so entropy around, say, 40 bits should also be fine."
         rationale: "With 300 Gigahashes/second in 2017, even MD5 will require over 50 years to crack 12 alphanumeric-character passwords, representing an entropy of about 70 bits. Thus, we define 70 bits as sufficient entropy. (Update this number as hardware improves.)"
            ->    containingData.insufficientEntropyOfKeyOrContainedData

      # unpredictable
         info: "If the information is predictable (e.g. default passwords), it is easier to crack when encrypted. For offline cracking, we define a predictable password as one that can be found (with a frequency higher than 1) in a dictionary such as RockYou. Even with 4096 iterations bcrypt, such passwords are cracked in an hour. (A slow bcrypt cracker does 100 hashes/second. With 90-95% probability, it will be enough to try the 360 000 most popular passwords in RockYou to find one randomly drawn from RockYou's accounts.)"
            ->    containingData.keyOrContainedDataPredictable

       | attemptBruteForceAttack
            //Placeholder for EncryptedData

       | attemptDictionaryAttack
            //Placeholder for EncryptedData

       | insufficientEntropyOfKeyOrContainedData
            //Placeholder for EncryptedData

       | keyOrContainedDataPredictable
            //Placeholder for EncryptedData

       & bruteForceAttack
            //Placeholder for EncryptedData

      & dictionaryAttack
            //Placeholder for EncryptedData
   }

   asset EncryptedData extends Data {
      | readAccess
         info: "The encrypted data can be read, but not deciphered."
            ->    decryptWithKey,
               exploitBrokenCryptography,
               exploitBrokenImplementation,
               attemptBruteForceAttack,
               attemptDictionaryAttack

       & exploitBrokenCryptography
            -> read

       & exploitBrokenImplementation
            -> read

       | accessKey
            -> decryptWithKey

       & decryptWithKey
            -> read

       | attemptBruteForceAttack
            -> bruteForceAttack

       | attemptDictionaryAttack
            -> dictionaryAttack

       & bruteForceAttack [UniformDistribution(0.0, 100.0)]
         info: "A raw brute-force attack is always possible, but feasible only sometimes. The distribution parameter (time for search space exhaustion) depends on the encryption scheme, the attacked entropy (e.g. key entropy), and the attacker equipment. It is therefore determined in crypto-suite-specializations of EncryptedData, e.g. MD5EncryptedData."
         rationale: "Raw brute-forcing is a linear process that has an equal chance of stumbling over the answer at any point between the start of the search and the complete exhaustion ofthe search space."
         // APT's might be expected to have a factor 10-100 times better performance than anything publically known? (http://www.dagbladet.no/nyheter/nis-aquires-supercomputer/61602521)
            ->    read

      & dictionaryAttack [GammaDistribution(0.3, 0.25)]
         info: "If the information is predictable (e.g. default passwords), it is easier to crack when encrypted. For offline cracking, we define a predictable password as one that can be found (with a frequency higher than 1) in a dictionary such as RockYou. Even with 4096 iterations bcrypt, such passwords are cracked in an hour. (A slow bcrypt cracker does 100 hashes/second. With 90-95% probability, it will be enough to try the 360 000 most popular passwords in RockYou to find one randomly drawn from RockYou's accounts.) "
         rationale: "The nominal Gamma distribution scale factor for RockYou is 2,000,000 (GammaDistribution(0.3, 2000000)). It should be divided by the number of hashes that can be brute-forced per day. For MD5, this would be 200 GH/s*3600*24. Even with 4096 iterations bcrypt, predictable passwords are cracked in an hour. (A slow bcrypt cracker does 100 hashes/second. With 90-95% probability, it will be enough to try the 360 000 most popular passwords in RockYou to find one randomly drawn from RockYou's accounts.) However, for online cracking, the number of hashes per day might be 3600*24, leading to GammaDistribution[0.3, 23], which would mean about a month for 95% cracking probability (Probability[t < 30, t belongs to GammaDistribution[0.3, 23]] = 0.945)."
         // APT's might be expected to have a factor 10-100 times better performance than anything publically known? (http://www.dagbladet.no/nyheter/nis-aquires-supercomputer/61602521)
            -> read

       | insufficientEntropyOfKeyOrContainedData
            -> bruteForceAttack

       | keyOrContainedDataPredictable
            ->    dictionaryAttack
   }

   asset EncryptedAuthenticatedData extends EncryptedData {

      | writeAccess
            info: "Writing does not lead to tampering unless authentication (e.g. signing) can be achieved."
            ->    readAccess,
               signWithKey,
               exploitBrokenImplementation,
               attemptBruteForceAttack,
               attemptDictionaryAttack,
               delete

       & exploitBrokenCryptography
            ->    read,
               write

       & exploitBrokenImplementation
            ->    read,
               write

       | accessKey
            ->    decryptWithKey,
               signWithKey

       & signWithKey
            -> write

       & bruteForceAttack [UniformDistribution(0.0, 100.0)]
         info: "A raw brute-force attack is always possible, but feasible only sometimes. The distribution parameter (time for search space exhaustion) depends on the encryption scheme, the attacked entropy (e.g. key entropy), and the attacker equipment. It is therefore determined in crypto-suite-specializations of EncryptedData, e.g. MD5EncryptedData."
         rationale: "Raw brute-forcing is a linear process that has an equal chance of stumbling over the answer at any point between the start of the search and the complete exhaustion ofthe search space."
         // APT's might be expected to have a factor 10-100 times better performance than anything publically known? (http://www.dagbladet.no/nyheter/nis-aquires-supercomputer/61602521)
            ->    read,
               write

      & dictionaryAttack [GammaDistribution(0.3, 0.25)]
         info: "If the information is predictable (e.g. default passwords), it is easier to crack when encrypted. For offline cracking, we define a predictable password as one that can be found (with a frequency higher than 1) in a dictionary such as RockYou. Even with 4096 iterations bcrypt, such passwords are cracked in an hour. (A slow bcrypt cracker does 100 hashes/second. With 90-95% probability, it will be enough to try the 360 000 most popular passwords in RockYou to find one randomly drawn from RockYou's accounts.) For online cracking (say 1 Hash/sec), "
         rationale: "The Gamma distribution scale factor should be divided by the number of hashes that can be brute-forced per day. For MD5, this would be 200 GH/s*3600*24. Even with 4096 iterations bcrypt, predictable passwords are cracked in an hour. (A slow bcrypt cracker does 100 hashes/second. With 90-95% probability, it will be enough to try the 360 000 most popular passwords in RockYou to find one randomly drawn from RockYou's accounts.) However, for online cracking, the number of hashes per day might be 360*24, leading to GammaDistribution[0.3, 231], which would mean about 300 days for 95% cracking probability."
         // APT's might be expected to have a factor 10-100 times better performance than anything publically known? (http://www.dagbladet.no/nyheter/nis-aquires-supercomputer/61602521)
            -> read,
               write
   }

   asset Dataflow
   info: "Dataflow is a channel that contains Data in transit."
   {
      | eavesdrop
            info: "An attacker that eavesdrops on the data flow, can access the contained data. That data may, in turn, be encrypted, thus preventing a breach of confidentiality."
            ->    data.readAccess,
               virtualNetwork.eavesdrop

      | manInTheMiddle
            info: "An attacker that man-in-the-middles the data flow, can control the contained data. That data may, in turn, be encrypted and authenticated, thus preventing a breach of confidentiality and integrity."
            ->    eavesdrop,
               denialOfService,
               requestAccess,
               respondAccess

      | tamper
            -> respond,
               request,
               virtualNetwork.manInTheMiddle

      | denialOfService
            info: "A denial-of-service-attack on the dataflow makes the contained data inaccessible. The information may, however also be available elsewhere."
            -> data.deleteAccess

      | requestAccess
            -> data.writeAccess,
               data.readAccess,
               data.deleteAccess,
               writeAccessNoModelledData,
               request

      & request
            info: "Tampering with data flows leads to altering of the contained information only if there is no untouched copy elsewhere. If data flows update data at rest, that data will also be affected by the tampering."
            rationale: "Both request and respond could affect the related information (cf. HTTP GET and HTTP POST) and data, so we do not distinguish between them. Instead, the flow of information is specified with the Propagation relationship."
            ->    services.legitimateConnect,
               maliciousRequestNoIDPS,
               maliciousRequestBypassIDPS

      & maliciousRequestNoIDPS
         info: "IDPS's can detect and prevent some types of malicious requests, thus reducing the probability of vulnerability exploitation."
            -> maliciousRequest

      | maliciousRequestBypassIDPS [ExponentialDistribution(6.13)]
         info: "IDPS's do not prevent all malicious requests, but it typically takes time for the attacker to bypass."
         rationale: "The time to bypass a tuned and updated IDPS is studied in 'T. Sommestad, H. Holm, M. Ekstedt, Estimates of success rates of remote arbitrary code execution attacks, Information Management & Computer Security (2012)' and 'H.Holm, T.Sommestad, U.Franke, M.Ekstedt, Success rate of remote code execution attacks â€“ expert assessments and observations, Journal of Universal Computer Science 18 (6) (2012)'"
         // These numbers should be updated, as encryption has become pervasive
            -> maliciousRequest

      | maliciousRequest
            -> services.attemptMaliciousConnect

      | respondAccess
            -> data.writeAccess,
               data.readAccess,
               data.deleteAccess,
               writeAccessNoModelledData,
               respond

      & respond
            info: "Tampering with data flows leads to altering of the contained information only if there is no untouched copy elsewhere. If data flows update data at rest, that data will also be affected by the tampering."
            rationale: "Both request and respond could affect the related information (cf. HTTP GET and HTTP POST) and data, so we do not distinguish between them. Instead, the flow of information is specified with the Propagation relationship."
            ->    clients.legitimateConnect,
               executingClients.rootAccess,
               maliciousRespondNoIDPS,
               maliciousRespondBypassIDPS

      & maliciousRespondNoIDPS
         info: "IDPS's can detect and prevent some types of malicious responses, thus reducing the probability of vulnerability exploitation."
            -> maliciousRespond

      | maliciousRespondBypassIDPS [ExponentialDistribution(6.13)]
         info: "IDPS's do not prevent all malicious responses, but it typically takes time for the attacker to bypass."
         rationale: "The time to bypass a tuned and updated IDPS is studied in 'T. Sommestad, H. Holm, M. Ekstedt, Estimates of success rates of remote arbitrary code execution attacks, Information Management & Computer Security (2012)' and 'H.Holm, T.Sommestad, U.Franke, M.Ekstedt, Success rate of remote code execution attacks â€“ expert assessments and observations, Journal of Universal Computer Science 18 (6) (2012)'"
         // These numbers should be updated, as encryption has become pervasive
            -> maliciousRespond

      | maliciousRespond
            -> clients.attemptMaliciousConnect

      3 noModelledData
            info: "If the dataflow does not explicitly model the contained data, results should still be reasonable. We assume unencrypted data, so e.g. MitM leads to respond and request."
            <- data
            -> writeNoModelledData

      | writeAccessNoModelledData
            info: "If the dataflow does not explicitly model the contained data, results should still be reasonable. We assume unencrypted data, so e.g. MitM leads to respond and request."
            -> writeNoModelledData

      & writeNoModelledData
            info: "If the dataflow does not explicitly model the contained data, results should still be reasonable. We assume unencrypted data, so e.g. MitM leads to respond and request."
            -> tamper

      3 idpsExists
            <- idps
            -> noIDPSProtection

      | noIDPSProtection
            info: "IDPS protection comes from (i) the existence of a (ii) correctly configured IDPS."
            -> maliciousRequestNoIDPS,
               maliciousRespondNoIDPS
   }
}

category Security {
   asset Account {
      & multiFactorAuthenticate
         info: "Multiple keys imply multi-factor authentication (all keys are needed)."
         // We can easily extend this to a muliple alternative multi-factor case (many alternative keys, possibly in them selves multi-factor).
            -> authenticate

      | attemptCrack
            ->    authenticationServices.attemptToBreakImplementation,
               attemptBruteForceAttack,
               attemptDictionaryAttack

      | authenticate
            ->    rootAccessedMachines.rootAuthenticate,
               userAccessedMachines.userAuthenticate,
               networks.userAuthenticate,
               readData.anyUserAccountRead,
               writtenData.anyUserAccountWrite,
               deletedData.anyUserAccountDelete,
               authenticatees.authenticate

      | backOffDisabled
         info: "The number of logon attempts is limited."
            -> credentials.bruteForceAttack

      | attemptBruteForceAttack
            -> credentials.attemptBruteForceAttack

      | attemptDictionaryAttack
            -> credentials.attemptDictionaryAttack

       & exploitBrokenImplementation
            ->    authenticate
   }

   asset Key extends Data {
       | read
            ->    accounts.multiFactorAuthenticate,
               encryptedData.accessKey,
               routers.bypassHandshakeEncryption

       // The below is not quite right. It assumes that the encryption of the containing data needs to be broken. But it is possible to brute force or dictionary-attack a password in an authentication service without involving any cryptography. The authentication service might, e.g., store the passwords in clear text.
       | attemptBruteForceAttack
            -> containingData.attemptBruteForceAttack

       | attemptDictionaryAttack
            -> containingData.attemptDictionaryAttack

       # sufficientEntropy
         info: "Keys need to feature suffciently high entropy to be uncrackable. 12 alphanumeric-character passwords, representing an entropy of about 70 bits contain sufficient entropy even for MD5. For online cracking, speeds are very much slower, around 1 Hash/s. Therefore, 70 bits is clearly excessive, even without back-off, so entropy around, say, 40 bits should also be fine."
         rationale: "With 300 Gigahashes/second in 2017, even MD5 will require over 50 years to crack 12 alphanumeric-character passwords, representing an entropy of about 70 bits. Thus, we define 70 bits as sufficient entropy. (Update this number as hardware improves.)"
            ->    containingData.insufficientEntropyOfKeyOrContainedData,
               encryptedData.insufficientEntropyOfKeyOrContainedData

      # unpredictable
            ->    containingData.keyOrContainedDataPredictable,
               encryptedData.keyOrContainedDataPredictable
   }

   asset Firewall extends Service
      info: "A firewall service may be running on its own hardware, or may be co-loated with a router on the same host. If functioning properly, it restricts traffic through the router."
      // Firewalls will not stop attacks over modelled dataflows. Such dataflows are assumed to be allowed by the firewall.
      {
      # correctlyConfigured
            info: "An incorrectly configured firewall is defined as one where the attacker will be able to gain layer-3 access to all of the protected network, thus connecting to all exposed network services."
            -> router.noFirewallProtection
   }

   asset IDPS extends Service {
      # correctlyConfigured
            -> dataflows.noIDPSProtection
   }
}

category People {
   asset Organization {
      | phishingAttempt
            -> employees.phishingAttempt
   }

   asset User {
      | phishingAttempt
            -> phishUnawareUser,
               phishAwareUser

      | phishAwareUser [ExponentialDistribution(13.99)]
         // I think these number are too high, reaching 30% in 5 days
            -> phish

      & phishUnawareUser [ExponentialDistribution(5.92)]
         // I think these number are too high, reaching 70% in 5 days
            -> phish

      | phish
            -> accounts.authenticate

      # securityAware
            -> phishUnawareUser
   }
}

category Zone {
   asset PhysicalZone{
      | compromise
         ->    physicalMachines.physicalAccess,
            networks.physicalAccess
   }
}


associations {
   Machine     [machines]                 *  <--   ProductInstallation           --> 1 [product]                  Product
   PhysicalMachine [physicalMachines]           *  <--   PhysicalAccess                --> 0-1  [physicalZone]             PhysicalZone
   Machine        [executor]                 0-1   <-- Execution                 --> * [executees]                Software
   Account     [rootAccount]              *  <-- RootExecutionPrivileges         --> * [rootAccessedMachines]        Machine
      info: "Root accounts have access to all data and all executees."
   Account     [userAccounts]             *  <-- UserExecutionPrivileges         --> * [userAccessedMachines]        Machine
      info: "User accounts have access according to specified access relations. If there are no defined accounts, simply connecting will lead to userAccess."
   Account     [authenticatedAccounts]       *  <-- AccountAuthentication        --> 1 [authenticationServices]      AuthenticationService
      info: "Conceptually, authentication is separated from access control (obvious in the case of e.g. Radius servers). authenticationServices provide the authentication service."
   Account     [assignedAccounts]            1-* <-- Assignment                  --> * [assignedSoftwares]        Software
      info: "Software needs to be granted certain privileges when executing on a platform. When the software is compromised, the attacker gains its privileges on the platform."
   Account     [authenticators]           *  <-- Authentication               --> * [authenticatees]           Account
      // When an association is defined between two instances of the same class, the direction can only be deciphered using the role name. In securiCAD, this needs to be addressed, as currently, only the association name is visible.
   Account     [accounts]                 *     <-- Credentials                  --> * [credentials]              Key
   Account     [readingAccounts]          *     <-- Read                   --> * [readData]                 Data
   Account     [writingAccounts]          *     <-- Write                     --> * [writtenData]              Data
   Account     [deletingAccounts]            *     <-- Delete                    --> * [deletedData]              Data
   Data        [containingData]           *  <-- Containment               --> * [containedData]            Data
   Data        [data]                     *  <-- Representation               --> 0-1  [information]              Information
      info: "The data constitutes a syntactic representation at rest of the information."
   Data        [data]                     *  <-- Storage                   --> * [machines]                 Machine
   EncryptedData  [encryptedData]               *  <-- Encryption                   --> 0-1 [encryptionKey]             Key
      info: "Data that is encrypted without a key is hashed, since hashing is equivalent to encrypting and throwing away the key."
      // I think that is true, but we need to check that.
   EncryptedData  [encryptedData]               *  <-- Encryption                   --> 1    [encryptionService]        EncryptionService
   Network     [trafficNetworks]             *  <-- Connection                   --> *    [trafficRouters]           Router
   Network     [networks]                 *  <-- PhysicalAccess               --> *    [physicalZones]            PhysicalZone
   Network     [networks]                 *  <-- Communication                --> * [dataflows]                Dataflow
   Ethernet       [exposureNetworks]            *   <-- NetworkExposure             -->   *  [exposedServices]             NetworkService
        rationale: "PSK belongs to the whole network (all parties have it), and is broadcast in the 4-way handshake of WPA PSK."
   Ethernet       [networks]                 *  <-- Connection                   --> *    [physicalMachines]            PhysicalMachine
      info: "Physical machines can be connected to networks. If services are not explicitly connected to other networks, it is assumed that they are communicating over the physically connected one."
   Ethernet       [networks]                 *  <-- Connection                   --> *    [virtualMachines]             VirtualMachine
   Wifi        [wifiTrafficNetworks]         *  <-- WifiConnection               --> *    [wifiTrafficRouters]          WifiRouter
    Wifi          [networks]                 *   <-- Authentication              --> 0-1 [authenticationService]     AuthenticationService
    Wifi          [networks]                 *   <-- UserExecutionPrivileges        --> 0-1 [userAccounts]              Account
    Wifi          [networks]                 *   <-- InitialHandshake            --> * [hashedCredentials]        EncryptedData
    WifiRouter       [routers]                  *  <-- CertificateAuthentication    --> 0-1  [certificate]              Key
   Dataflow    [dataflows]                *  <-- ClientRequest                --> * [clients]                  Client
   Dataflow    [dataflows]                *  <-- ServerResponse               --> * [services]                 NetworkService
   Dataflow    [programDistributionFlow]     *  <-- ProgramDistributionToClient     --> * [executingClients]            Client
      info: "Some servers distribute programs to clients, e.g. software updates, or Web applications."
   Dataflow    [programDistributionFlow]     *  <-- ProgramDistributionFromServer   --> * [providingServices]        NetworkService
      info: "Some servers distribute programs to clients, e.g. software updates, or Web applications."
   Dataflow    [dataflow]                 0-1 <-- Transmission                --> 0-1  [data]                     Data
   Dataflow    [realizingDataflow]           *  <-- NetworkVirtualization        --> 0-1  [virtualNetwork]           Network
      info: "The dataflow transmits data."
      rationale: "A dataflow cannot feature multiple data, as these may have different properties, e.g. one authenticated and one not."
   Data        [sourceData]               *  <-- Propagation                  --> * [targetData]               Data
      info: "The information contents of source data become part of the contents of target data."
      // Encryption relations should be autogenerated from the sourceData's encryptionService to the targetData.
   Firewall    [firewall]                 0-1   <-- FirewallProtection           --> 1 [router]                Router
   IDPS        [idps]                     *  <-- IDPSProtection               --> * [dataflows]                Dataflow
   Organization   [organizations]               *  <-- Employment                -->   *  [employees]                User
   User        [users]                    *     <-- UserAccount               --> * [accounts]                 Account
      info: "An IDPS detects and prevents some malicious requests and responses in dataflows."
}

